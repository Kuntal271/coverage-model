@startuml

hide circle
hide stereotype

skinparam class {
  BackgroundColor #f0f0f0
  BorderColor #a0a0a0
  BackgroundColor<<Nodes>> cornsilk
  BackgroundColor<<Values>> moccasin
  BorderColor black
  ArrowColor black
  FontName  Arial Unicode MS
  FontSize 20
}
skinparam classFontSize 24
skinparam classAttributeIconSize 0
skinparam defaultFontSize 20

skinparam ArrowColor black
skinparam ArrowThickness 2

package coverage as "edu.hm.hafner.coverage" {
abstract class CoverageParser {
+ {abstract}parse(reader, log): ModuleNode
}

class parser.CoberturaParser {
+ parse(reader, log): ModuleNode
}

class parser.JacocoParser {
+ parse(reader, log): ModuleNode
}

class parser.PitestParser {
+ parse(reader, log): ModuleNode
}

abstract class Node <<Nodes>> {
- metric: Metric <<pk>>
- name: Name <<pk>>

+ {abstract} copy(): Node
}

class ContainerNode <<Nodes>> {
+ copy(): ContainerNode
}

class ModuleNode <<Nodes>> {
- sources: List<String>
+ copy(): ModuleNode
+ splitPackages()
}

class PackageNode <<Nodes>> {
+ getPath(): String
+ copy(): PackageNode
}

class ClassNode <<Nodes>> {
+ copy(): ClassNode
}

class MethodNode <<Nodes>> {
- lineNumber: Integer
- signature: String
+ copy(): MethodNode
}

class FileNode <<Nodes>> {
+ copy(): FileNode
}

abstract class Value <<Values>> {
- metric: Metric
+ {abstract}add(other: Value): Value
+ {abstract}max(other: Value): Value
+ {abstract}delta(other: Value): Fraction
+ {abstract}isBelowThreshold(double): boolean
+ {abstract}String serialize()
}

class CyclomaticComplexity <<Values>> {
# create(integer: Integer): IntegerValue
}

class LinesOfCode <<Values>> {
# create(integer: Integer): IntegerValue
}

class Coverage <<Values>> {
- covered: Integer
- missed: Integer
+ isSet(): Boolean
+ add(other: Value): Value
+ max(other: Value): Value
+ delta(other: Value): Fraction
+ isBelowThreshold(double): boolean
+ String serialize()
}

class FractionValue <<Values>> {
- fraction: Fraction
+ add(other: Value): Value
+ max(other: Value): Value
+ delta(other: Value): Fraction
+ isBelowThreshold(double): boolean
+ String serialize()
}

abstract class IntegerValue <<Values>> {
- integer: Integer
+ add(other: Value): Value
+ max(other: Value): Value
+ delta(other: Value): Fraction
+ isBelowThreshold(double): boolean
+ String serialize()
# {abstract}create(integer: Integer): IntegerValue
}

class Mutation {
+ boolean isDetected()
+ MutationStatus getStatus()
+ int getLineNumber()
+ Mutator getMutator()
+ String getKillingTest()
+ boolean isKilled()
}

IntegerValue <|-up- LinesOfCode
IntegerValue <|-up- CyclomaticComplexity

Value <|-up- Coverage
Value <|-up- FractionValue
Value <|-up- IntegerValue

Node <|-- MethodNode
Node <|-- ClassNode
Node <|-- PackageNode
Node <|-- ModuleNode
Node <|-- ContainerNode
Node <|-- FileNode

CoverageParser <|-- parser.PitestParser
CoverageParser <|-- parser.JacocoParser
CoverageParser <|-- parser.CoberturaParser

Node o- Node: children

FileNode o-left- Mutation
Value -o Node : values\t
Value -[hidden]-- CoverageParser

}

@enduml
